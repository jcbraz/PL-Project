Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT
    DOT

Grammar

Rule 0     S' -> document
Rule 1     document -> items
Rule 2     items -> item items
Rule 3     items -> item
Rule 4     item -> KEY EQUAL value NEWLINE
Rule 5     item -> KEY EQUAL value
Rule 6     item -> KEY LBRACKET RBRACKET NEWLINE
Rule 7     item -> KEY LBRACKET RBRACKET
Rule 8     item -> NEWLINE
Rule 9     value -> STRING
Rule 10    value -> INTEGER
Rule 11    value -> FLOAT
Rule 12    value -> BOOLEAN
Rule 13    value -> DATE
Rule 14    value -> array
Rule 15    value -> inline_table
Rule 16    array -> LBRACKET values RBRACKET
Rule 17    values -> value COMMA values
Rule 18    values -> value
Rule 19    inline_table -> LCURLY pairs RCURLY
Rule 20    pairs -> KEY EQUAL value COMMA pairs
Rule 21    pairs -> KEY EQUAL value

Terminals, with rules where they appear

BOOLEAN              : 12
COMMA                : 17 20
COMMENT              : 
DATE                 : 13
DOT                  : 
EQUAL                : 4 5 20 21
FLOAT                : 11
INTEGER              : 10
KEY                  : 4 5 6 7 20 21
LBRACKET             : 6 7 16
LCURLY               : 19
NEWLINE              : 4 6 8
RBRACKET             : 6 7 16
RCURLY               : 19
STRING               : 9
error                : 

Nonterminals, with rules where they appear

array                : 14
document             : 0
inline_table         : 15
item                 : 2 3
items                : 1 2
pairs                : 19 20
value                : 4 5 17 18 20 21
values               : 16 17

Parsing method: LALR

state 0

    (0) S' -> . document
    (1) document -> . items
    (2) items -> . item items
    (3) items -> . item
    (4) item -> . KEY EQUAL value NEWLINE
    (5) item -> . KEY EQUAL value
    (6) item -> . KEY LBRACKET RBRACKET NEWLINE
    (7) item -> . KEY LBRACKET RBRACKET
    (8) item -> . NEWLINE

    KEY             shift and go to state 4
    NEWLINE         shift and go to state 5

    document                       shift and go to state 1
    items                          shift and go to state 2
    item                           shift and go to state 3

state 1

    (0) S' -> document .



state 2

    (1) document -> items .

    $end            reduce using rule 1 (document -> items .)


state 3

    (2) items -> item . items
    (3) items -> item .
    (2) items -> . item items
    (3) items -> . item
    (4) item -> . KEY EQUAL value NEWLINE
    (5) item -> . KEY EQUAL value
    (6) item -> . KEY LBRACKET RBRACKET NEWLINE
    (7) item -> . KEY LBRACKET RBRACKET
    (8) item -> . NEWLINE

    $end            reduce using rule 3 (items -> item .)
    KEY             shift and go to state 4
    NEWLINE         shift and go to state 5

    item                           shift and go to state 3
    items                          shift and go to state 6

state 4

    (4) item -> KEY . EQUAL value NEWLINE
    (5) item -> KEY . EQUAL value
    (6) item -> KEY . LBRACKET RBRACKET NEWLINE
    (7) item -> KEY . LBRACKET RBRACKET

    EQUAL           shift and go to state 7
    LBRACKET        shift and go to state 8


state 5

    (8) item -> NEWLINE .

    KEY             reduce using rule 8 (item -> NEWLINE .)
    NEWLINE         reduce using rule 8 (item -> NEWLINE .)
    $end            reduce using rule 8 (item -> NEWLINE .)


state 6

    (2) items -> item items .

    $end            reduce using rule 2 (items -> item items .)


state 7

    (4) item -> KEY EQUAL . value NEWLINE
    (5) item -> KEY EQUAL . value
    (9) value -> . STRING
    (10) value -> . INTEGER
    (11) value -> . FLOAT
    (12) value -> . BOOLEAN
    (13) value -> . DATE
    (14) value -> . array
    (15) value -> . inline_table
    (16) array -> . LBRACKET values RBRACKET
    (19) inline_table -> . LCURLY pairs RCURLY

    STRING          shift and go to state 10
    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    BOOLEAN         shift and go to state 13
    DATE            shift and go to state 14
    LBRACKET        shift and go to state 17
    LCURLY          shift and go to state 18

    value                          shift and go to state 9
    array                          shift and go to state 15
    inline_table                   shift and go to state 16

state 8

    (6) item -> KEY LBRACKET . RBRACKET NEWLINE
    (7) item -> KEY LBRACKET . RBRACKET

    RBRACKET        shift and go to state 19


state 9

    (4) item -> KEY EQUAL value . NEWLINE
    (5) item -> KEY EQUAL value .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 20
    KEY             reduce using rule 5 (item -> KEY EQUAL value .)
    $end            reduce using rule 5 (item -> KEY EQUAL value .)

  ! NEWLINE         [ reduce using rule 5 (item -> KEY EQUAL value .) ]


state 10

    (9) value -> STRING .

    NEWLINE         reduce using rule 9 (value -> STRING .)
    KEY             reduce using rule 9 (value -> STRING .)
    $end            reduce using rule 9 (value -> STRING .)
    COMMA           reduce using rule 9 (value -> STRING .)
    RBRACKET        reduce using rule 9 (value -> STRING .)
    RCURLY          reduce using rule 9 (value -> STRING .)


state 11

    (10) value -> INTEGER .

    NEWLINE         reduce using rule 10 (value -> INTEGER .)
    KEY             reduce using rule 10 (value -> INTEGER .)
    $end            reduce using rule 10 (value -> INTEGER .)
    COMMA           reduce using rule 10 (value -> INTEGER .)
    RBRACKET        reduce using rule 10 (value -> INTEGER .)
    RCURLY          reduce using rule 10 (value -> INTEGER .)


state 12

    (11) value -> FLOAT .

    NEWLINE         reduce using rule 11 (value -> FLOAT .)
    KEY             reduce using rule 11 (value -> FLOAT .)
    $end            reduce using rule 11 (value -> FLOAT .)
    COMMA           reduce using rule 11 (value -> FLOAT .)
    RBRACKET        reduce using rule 11 (value -> FLOAT .)
    RCURLY          reduce using rule 11 (value -> FLOAT .)


state 13

    (12) value -> BOOLEAN .

    NEWLINE         reduce using rule 12 (value -> BOOLEAN .)
    KEY             reduce using rule 12 (value -> BOOLEAN .)
    $end            reduce using rule 12 (value -> BOOLEAN .)
    COMMA           reduce using rule 12 (value -> BOOLEAN .)
    RBRACKET        reduce using rule 12 (value -> BOOLEAN .)
    RCURLY          reduce using rule 12 (value -> BOOLEAN .)


state 14

    (13) value -> DATE .

    NEWLINE         reduce using rule 13 (value -> DATE .)
    KEY             reduce using rule 13 (value -> DATE .)
    $end            reduce using rule 13 (value -> DATE .)
    COMMA           reduce using rule 13 (value -> DATE .)
    RBRACKET        reduce using rule 13 (value -> DATE .)
    RCURLY          reduce using rule 13 (value -> DATE .)


state 15

    (14) value -> array .

    NEWLINE         reduce using rule 14 (value -> array .)
    KEY             reduce using rule 14 (value -> array .)
    $end            reduce using rule 14 (value -> array .)
    COMMA           reduce using rule 14 (value -> array .)
    RBRACKET        reduce using rule 14 (value -> array .)
    RCURLY          reduce using rule 14 (value -> array .)


state 16

    (15) value -> inline_table .

    NEWLINE         reduce using rule 15 (value -> inline_table .)
    KEY             reduce using rule 15 (value -> inline_table .)
    $end            reduce using rule 15 (value -> inline_table .)
    COMMA           reduce using rule 15 (value -> inline_table .)
    RBRACKET        reduce using rule 15 (value -> inline_table .)
    RCURLY          reduce using rule 15 (value -> inline_table .)


state 17

    (16) array -> LBRACKET . values RBRACKET
    (17) values -> . value COMMA values
    (18) values -> . value
    (9) value -> . STRING
    (10) value -> . INTEGER
    (11) value -> . FLOAT
    (12) value -> . BOOLEAN
    (13) value -> . DATE
    (14) value -> . array
    (15) value -> . inline_table
    (16) array -> . LBRACKET values RBRACKET
    (19) inline_table -> . LCURLY pairs RCURLY

    STRING          shift and go to state 10
    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    BOOLEAN         shift and go to state 13
    DATE            shift and go to state 14
    LBRACKET        shift and go to state 17
    LCURLY          shift and go to state 18

    values                         shift and go to state 21
    value                          shift and go to state 22
    array                          shift and go to state 15
    inline_table                   shift and go to state 16

state 18

    (19) inline_table -> LCURLY . pairs RCURLY
    (20) pairs -> . KEY EQUAL value COMMA pairs
    (21) pairs -> . KEY EQUAL value

    KEY             shift and go to state 24

    pairs                          shift and go to state 23

state 19

    (6) item -> KEY LBRACKET RBRACKET . NEWLINE
    (7) item -> KEY LBRACKET RBRACKET .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 25
    KEY             reduce using rule 7 (item -> KEY LBRACKET RBRACKET .)
    $end            reduce using rule 7 (item -> KEY LBRACKET RBRACKET .)

  ! NEWLINE         [ reduce using rule 7 (item -> KEY LBRACKET RBRACKET .) ]


state 20

    (4) item -> KEY EQUAL value NEWLINE .

    KEY             reduce using rule 4 (item -> KEY EQUAL value NEWLINE .)
    NEWLINE         reduce using rule 4 (item -> KEY EQUAL value NEWLINE .)
    $end            reduce using rule 4 (item -> KEY EQUAL value NEWLINE .)


state 21

    (16) array -> LBRACKET values . RBRACKET

    RBRACKET        shift and go to state 26


state 22

    (17) values -> value . COMMA values
    (18) values -> value .

    COMMA           shift and go to state 27
    RBRACKET        reduce using rule 18 (values -> value .)


state 23

    (19) inline_table -> LCURLY pairs . RCURLY

    RCURLY          shift and go to state 28


state 24

    (20) pairs -> KEY . EQUAL value COMMA pairs
    (21) pairs -> KEY . EQUAL value

    EQUAL           shift and go to state 29


state 25

    (6) item -> KEY LBRACKET RBRACKET NEWLINE .

    KEY             reduce using rule 6 (item -> KEY LBRACKET RBRACKET NEWLINE .)
    NEWLINE         reduce using rule 6 (item -> KEY LBRACKET RBRACKET NEWLINE .)
    $end            reduce using rule 6 (item -> KEY LBRACKET RBRACKET NEWLINE .)


state 26

    (16) array -> LBRACKET values RBRACKET .

    NEWLINE         reduce using rule 16 (array -> LBRACKET values RBRACKET .)
    KEY             reduce using rule 16 (array -> LBRACKET values RBRACKET .)
    $end            reduce using rule 16 (array -> LBRACKET values RBRACKET .)
    COMMA           reduce using rule 16 (array -> LBRACKET values RBRACKET .)
    RBRACKET        reduce using rule 16 (array -> LBRACKET values RBRACKET .)
    RCURLY          reduce using rule 16 (array -> LBRACKET values RBRACKET .)


state 27

    (17) values -> value COMMA . values
    (17) values -> . value COMMA values
    (18) values -> . value
    (9) value -> . STRING
    (10) value -> . INTEGER
    (11) value -> . FLOAT
    (12) value -> . BOOLEAN
    (13) value -> . DATE
    (14) value -> . array
    (15) value -> . inline_table
    (16) array -> . LBRACKET values RBRACKET
    (19) inline_table -> . LCURLY pairs RCURLY

    STRING          shift and go to state 10
    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    BOOLEAN         shift and go to state 13
    DATE            shift and go to state 14
    LBRACKET        shift and go to state 17
    LCURLY          shift and go to state 18

    value                          shift and go to state 22
    values                         shift and go to state 30
    array                          shift and go to state 15
    inline_table                   shift and go to state 16

state 28

    (19) inline_table -> LCURLY pairs RCURLY .

    NEWLINE         reduce using rule 19 (inline_table -> LCURLY pairs RCURLY .)
    KEY             reduce using rule 19 (inline_table -> LCURLY pairs RCURLY .)
    $end            reduce using rule 19 (inline_table -> LCURLY pairs RCURLY .)
    COMMA           reduce using rule 19 (inline_table -> LCURLY pairs RCURLY .)
    RBRACKET        reduce using rule 19 (inline_table -> LCURLY pairs RCURLY .)
    RCURLY          reduce using rule 19 (inline_table -> LCURLY pairs RCURLY .)


state 29

    (20) pairs -> KEY EQUAL . value COMMA pairs
    (21) pairs -> KEY EQUAL . value
    (9) value -> . STRING
    (10) value -> . INTEGER
    (11) value -> . FLOAT
    (12) value -> . BOOLEAN
    (13) value -> . DATE
    (14) value -> . array
    (15) value -> . inline_table
    (16) array -> . LBRACKET values RBRACKET
    (19) inline_table -> . LCURLY pairs RCURLY

    STRING          shift and go to state 10
    INTEGER         shift and go to state 11
    FLOAT           shift and go to state 12
    BOOLEAN         shift and go to state 13
    DATE            shift and go to state 14
    LBRACKET        shift and go to state 17
    LCURLY          shift and go to state 18

    value                          shift and go to state 31
    array                          shift and go to state 15
    inline_table                   shift and go to state 16

state 30

    (17) values -> value COMMA values .

    RBRACKET        reduce using rule 17 (values -> value COMMA values .)


state 31

    (20) pairs -> KEY EQUAL value . COMMA pairs
    (21) pairs -> KEY EQUAL value .

    COMMA           shift and go to state 32
    RCURLY          reduce using rule 21 (pairs -> KEY EQUAL value .)


state 32

    (20) pairs -> KEY EQUAL value COMMA . pairs
    (20) pairs -> . KEY EQUAL value COMMA pairs
    (21) pairs -> . KEY EQUAL value

    KEY             shift and go to state 24

    pairs                          shift and go to state 33

state 33

    (20) pairs -> KEY EQUAL value COMMA pairs .

    RCURLY          reduce using rule 20 (pairs -> KEY EQUAL value COMMA pairs .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for NEWLINE in state 9 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 19 resolved as shift
